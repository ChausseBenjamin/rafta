// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: schema.proto

package model

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Rafta_GetAllTasks_FullMethodName       = "/Rafta/GetAllTasks"
	Rafta_GetTask_FullMethodName           = "/Rafta/GetTask"
	Rafta_GetUserInfo_FullMethodName       = "/Rafta/GetUserInfo"
	Rafta_DeleteUser_FullMethodName        = "/Rafta/DeleteUser"
	Rafta_UpdateCredentials_FullMethodName = "/Rafta/UpdateCredentials"
	Rafta_UpdateUserInfo_FullMethodName    = "/Rafta/UpdateUserInfo"
	Rafta_NewTask_FullMethodName           = "/Rafta/NewTask"
	Rafta_DeleteTask_FullMethodName        = "/Rafta/DeleteTask"
	Rafta_UpdateTask_FullMethodName        = "/Rafta/UpdateTask"
)

// RaftaClient is the client API for Rafta service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service for user and task management accessible to authenticated users.
type RaftaClient interface {
	GetAllTasks(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TaskList, error)
	GetTask(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*Task, error)
	GetUserInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*User, error)
	DeleteUser(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateCredentials(ctx context.Context, in *PasswdMessage, opts ...grpc.CallOption) (*timestamppb.Timestamp, error)
	UpdateUserInfo(ctx context.Context, in *UserData, opts ...grpc.CallOption) (*timestamppb.Timestamp, error)
	NewTask(ctx context.Context, in *TaskData, opts ...grpc.CallOption) (*NewTaskResponse, error)
	DeleteTask(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateTask(ctx context.Context, in *TaskUpdateRequest, opts ...grpc.CallOption) (*TaskUpdateResponse, error)
}

type raftaClient struct {
	cc grpc.ClientConnInterface
}

func NewRaftaClient(cc grpc.ClientConnInterface) RaftaClient {
	return &raftaClient{cc}
}

func (c *raftaClient) GetAllTasks(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TaskList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskList)
	err := c.cc.Invoke(ctx, Rafta_GetAllTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftaClient) GetTask(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*Task, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Task)
	err := c.cc.Invoke(ctx, Rafta_GetTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftaClient) GetUserInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, Rafta_GetUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftaClient) DeleteUser(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rafta_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftaClient) UpdateCredentials(ctx context.Context, in *PasswdMessage, opts ...grpc.CallOption) (*timestamppb.Timestamp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(timestamppb.Timestamp)
	err := c.cc.Invoke(ctx, Rafta_UpdateCredentials_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftaClient) UpdateUserInfo(ctx context.Context, in *UserData, opts ...grpc.CallOption) (*timestamppb.Timestamp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(timestamppb.Timestamp)
	err := c.cc.Invoke(ctx, Rafta_UpdateUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftaClient) NewTask(ctx context.Context, in *TaskData, opts ...grpc.CallOption) (*NewTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NewTaskResponse)
	err := c.cc.Invoke(ctx, Rafta_NewTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftaClient) DeleteTask(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Rafta_DeleteTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftaClient) UpdateTask(ctx context.Context, in *TaskUpdateRequest, opts ...grpc.CallOption) (*TaskUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskUpdateResponse)
	err := c.cc.Invoke(ctx, Rafta_UpdateTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaftaServer is the server API for Rafta service.
// All implementations must embed UnimplementedRaftaServer
// for forward compatibility.
//
// Service for user and task management accessible to authenticated users.
type RaftaServer interface {
	GetAllTasks(context.Context, *emptypb.Empty) (*TaskList, error)
	GetTask(context.Context, *UUID) (*Task, error)
	GetUserInfo(context.Context, *emptypb.Empty) (*User, error)
	DeleteUser(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	UpdateCredentials(context.Context, *PasswdMessage) (*timestamppb.Timestamp, error)
	UpdateUserInfo(context.Context, *UserData) (*timestamppb.Timestamp, error)
	NewTask(context.Context, *TaskData) (*NewTaskResponse, error)
	DeleteTask(context.Context, *UUID) (*emptypb.Empty, error)
	UpdateTask(context.Context, *TaskUpdateRequest) (*TaskUpdateResponse, error)
	mustEmbedUnimplementedRaftaServer()
}

// UnimplementedRaftaServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRaftaServer struct{}

func (UnimplementedRaftaServer) GetAllTasks(context.Context, *emptypb.Empty) (*TaskList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllTasks not implemented")
}
func (UnimplementedRaftaServer) GetTask(context.Context, *UUID) (*Task, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTask not implemented")
}
func (UnimplementedRaftaServer) GetUserInfo(context.Context, *emptypb.Empty) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}
func (UnimplementedRaftaServer) DeleteUser(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedRaftaServer) UpdateCredentials(context.Context, *PasswdMessage) (*timestamppb.Timestamp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCredentials not implemented")
}
func (UnimplementedRaftaServer) UpdateUserInfo(context.Context, *UserData) (*timestamppb.Timestamp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserInfo not implemented")
}
func (UnimplementedRaftaServer) NewTask(context.Context, *TaskData) (*NewTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewTask not implemented")
}
func (UnimplementedRaftaServer) DeleteTask(context.Context, *UUID) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTask not implemented")
}
func (UnimplementedRaftaServer) UpdateTask(context.Context, *TaskUpdateRequest) (*TaskUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTask not implemented")
}
func (UnimplementedRaftaServer) mustEmbedUnimplementedRaftaServer() {}
func (UnimplementedRaftaServer) testEmbeddedByValue()               {}

// UnsafeRaftaServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RaftaServer will
// result in compilation errors.
type UnsafeRaftaServer interface {
	mustEmbedUnimplementedRaftaServer()
}

func RegisterRaftaServer(s grpc.ServiceRegistrar, srv RaftaServer) {
	// If the following call pancis, it indicates UnimplementedRaftaServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Rafta_ServiceDesc, srv)
}

func _Rafta_GetAllTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftaServer).GetAllTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rafta_GetAllTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftaServer).GetAllTasks(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rafta_GetTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftaServer).GetTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rafta_GetTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftaServer).GetTask(ctx, req.(*UUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rafta_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftaServer).GetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rafta_GetUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftaServer).GetUserInfo(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rafta_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftaServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rafta_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftaServer).DeleteUser(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rafta_UpdateCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PasswdMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftaServer).UpdateCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rafta_UpdateCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftaServer).UpdateCredentials(ctx, req.(*PasswdMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rafta_UpdateUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftaServer).UpdateUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rafta_UpdateUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftaServer).UpdateUserInfo(ctx, req.(*UserData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rafta_NewTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftaServer).NewTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rafta_NewTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftaServer).NewTask(ctx, req.(*TaskData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rafta_DeleteTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftaServer).DeleteTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rafta_DeleteTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftaServer).DeleteTask(ctx, req.(*UUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rafta_UpdateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftaServer).UpdateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Rafta_UpdateTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftaServer).UpdateTask(ctx, req.(*TaskUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Rafta_ServiceDesc is the grpc.ServiceDesc for Rafta service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Rafta_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Rafta",
	HandlerType: (*RaftaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllTasks",
			Handler:    _Rafta_GetAllTasks_Handler,
		},
		{
			MethodName: "GetTask",
			Handler:    _Rafta_GetTask_Handler,
		},
		{
			MethodName: "GetUserInfo",
			Handler:    _Rafta_GetUserInfo_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _Rafta_DeleteUser_Handler,
		},
		{
			MethodName: "UpdateCredentials",
			Handler:    _Rafta_UpdateCredentials_Handler,
		},
		{
			MethodName: "UpdateUserInfo",
			Handler:    _Rafta_UpdateUserInfo_Handler,
		},
		{
			MethodName: "NewTask",
			Handler:    _Rafta_NewTask_Handler,
		},
		{
			MethodName: "DeleteTask",
			Handler:    _Rafta_DeleteTask_Handler,
		},
		{
			MethodName: "UpdateTask",
			Handler:    _Rafta_UpdateTask_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "schema.proto",
}

const (
	Admin_GetAllUsers_FullMethodName       = "/Admin/GetAllUsers"
	Admin_GetUser_FullMethodName           = "/Admin/GetUser"
	Admin_GetUserTasks_FullMethodName      = "/Admin/GetUserTasks"
	Admin_UpdateCredentials_FullMethodName = "/Admin/UpdateCredentials"
	Admin_NewUser_FullMethodName           = "/Admin/NewUser"
	Admin_DeleteUser_FullMethodName        = "/Admin/DeleteUser"
	Admin_UpdateUser_FullMethodName        = "/Admin/UpdateUser"
	Admin_GetUserRoles_FullMethodName      = "/Admin/GetUserRoles"
	Admin_UpdateUserRoles_FullMethodName   = "/Admin/UpdateUserRoles"
)

// AdminClient is the client API for Admin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service for administrative operations accessible only to users with the
// ADMIN role
type AdminClient interface {
	// Retrieves a list of all users in the system. This is useful for admins to
	// get an overview of the user base or perform bulk operations.
	//
	// ***IF YOU'RE A SERVER ADMIN, PLZ BE NICE, DON'T VIOLATE USER PRIVACY***
	GetAllUsers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserList, error)
	// Retrieves the details of a specific user. This is helpful for admins to
	// view user information for troubleshooting or auditing purposes.
	//
	// ***IF YOU'RE A SERVER ADMIN, PLZ BE NICE, DON'T VIOLATE USER PRIVACY***
	GetUser(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*User, error)
	// GetUserTasks is meant to exist as a debugging tool to troubleshoot if a
	// users tasks seem broken in some way. It allows a admin to investigate
	// the issue without impersonating the user.
	//
	// ***IF YOU'RE A SERVER ADMIN, PLZ BE NICE, DON'T INVADE PEOPLES PRIVACY***
	GetUserTasks(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*TaskList, error)
	// This is allows the admin of the platform to change a user's passwords.
	// This is meant as a tool to help users that have lost their password.
	//
	// ***IF YOU'RE A SERVER ADMIN, PLZ BE NICE, DON'T LOCK PEOPLE OUT***
	UpdateCredentials(ctx context.Context, in *ChangePasswdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// An admin isn't meant to login as another user therefore no JWT is sent
	// This is mostly useful for server maintainers that want to create accounts
	// for friends without enabling public signups.
	//
	// ***IF YOU'RE A SERVER ADMIN, PLZ BE NICE, ASK USERS TO UPDATE THEIR CREDS***
	NewUser(ctx context.Context, in *UserSignupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Deletes a specific user by their UUID. This is meant as a tool for admins to
	// remove malicious users.
	//
	// ***IF YOU'RE A SERVER ADMIN, PLZ BE NICE, DONT DELETE PEOPLE UNWARANTED***
	DeleteUser(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Updates the details of a specific user. This is meant to allow admins to
	// correct user information or update their profiles as needed.
	//
	// ***IF YOU'RE A SERVER ADMIN, PLZ BE NICE, DON'T EDIT USERS UNWARANTED***
	UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Since role information is only packaged in JWTs (which an admin can't get
	// from another user), this is meant to help admins track which users have
	// special rights.
	GetUserRoles(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*UserRoles, error)
	// Allows an admin to add other admins to the platform to ease server
	// management The only moment this will refuse to work is when the only
	// admin of a server tries to revoke his own role.
	UpdateUserRoles(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type adminClient struct {
	cc grpc.ClientConnInterface
}

func NewAdminClient(cc grpc.ClientConnInterface) AdminClient {
	return &adminClient{cc}
}

func (c *adminClient) GetAllUsers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserList)
	err := c.cc.Invoke(ctx, Admin_GetAllUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) GetUser(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, Admin_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) GetUserTasks(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*TaskList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskList)
	err := c.cc.Invoke(ctx, Admin_GetUserTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) UpdateCredentials(ctx context.Context, in *ChangePasswdRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Admin_UpdateCredentials_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) NewUser(ctx context.Context, in *UserSignupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Admin_NewUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) DeleteUser(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Admin_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Admin_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) GetUserRoles(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*UserRoles, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserRoles)
	err := c.cc.Invoke(ctx, Admin_GetUserRoles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) UpdateUserRoles(ctx context.Context, in *UUID, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Admin_UpdateUserRoles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdminServer is the server API for Admin service.
// All implementations must embed UnimplementedAdminServer
// for forward compatibility.
//
// Service for administrative operations accessible only to users with the
// ADMIN role
type AdminServer interface {
	// Retrieves a list of all users in the system. This is useful for admins to
	// get an overview of the user base or perform bulk operations.
	//
	// ***IF YOU'RE A SERVER ADMIN, PLZ BE NICE, DON'T VIOLATE USER PRIVACY***
	GetAllUsers(context.Context, *emptypb.Empty) (*UserList, error)
	// Retrieves the details of a specific user. This is helpful for admins to
	// view user information for troubleshooting or auditing purposes.
	//
	// ***IF YOU'RE A SERVER ADMIN, PLZ BE NICE, DON'T VIOLATE USER PRIVACY***
	GetUser(context.Context, *UUID) (*User, error)
	// GetUserTasks is meant to exist as a debugging tool to troubleshoot if a
	// users tasks seem broken in some way. It allows a admin to investigate
	// the issue without impersonating the user.
	//
	// ***IF YOU'RE A SERVER ADMIN, PLZ BE NICE, DON'T INVADE PEOPLES PRIVACY***
	GetUserTasks(context.Context, *UUID) (*TaskList, error)
	// This is allows the admin of the platform to change a user's passwords.
	// This is meant as a tool to help users that have lost their password.
	//
	// ***IF YOU'RE A SERVER ADMIN, PLZ BE NICE, DON'T LOCK PEOPLE OUT***
	UpdateCredentials(context.Context, *ChangePasswdRequest) (*emptypb.Empty, error)
	// An admin isn't meant to login as another user therefore no JWT is sent
	// This is mostly useful for server maintainers that want to create accounts
	// for friends without enabling public signups.
	//
	// ***IF YOU'RE A SERVER ADMIN, PLZ BE NICE, ASK USERS TO UPDATE THEIR CREDS***
	NewUser(context.Context, *UserSignupRequest) (*emptypb.Empty, error)
	// Deletes a specific user by their UUID. This is meant as a tool for admins to
	// remove malicious users.
	//
	// ***IF YOU'RE A SERVER ADMIN, PLZ BE NICE, DONT DELETE PEOPLE UNWARANTED***
	DeleteUser(context.Context, *UUID) (*emptypb.Empty, error)
	// Updates the details of a specific user. This is meant to allow admins to
	// correct user information or update their profiles as needed.
	//
	// ***IF YOU'RE A SERVER ADMIN, PLZ BE NICE, DON'T EDIT USERS UNWARANTED***
	UpdateUser(context.Context, *User) (*emptypb.Empty, error)
	// Since role information is only packaged in JWTs (which an admin can't get
	// from another user), this is meant to help admins track which users have
	// special rights.
	GetUserRoles(context.Context, *UUID) (*UserRoles, error)
	// Allows an admin to add other admins to the platform to ease server
	// management The only moment this will refuse to work is when the only
	// admin of a server tries to revoke his own role.
	UpdateUserRoles(context.Context, *UUID) (*emptypb.Empty, error)
	mustEmbedUnimplementedAdminServer()
}

// UnimplementedAdminServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAdminServer struct{}

func (UnimplementedAdminServer) GetAllUsers(context.Context, *emptypb.Empty) (*UserList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllUsers not implemented")
}
func (UnimplementedAdminServer) GetUser(context.Context, *UUID) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedAdminServer) GetUserTasks(context.Context, *UUID) (*TaskList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserTasks not implemented")
}
func (UnimplementedAdminServer) UpdateCredentials(context.Context, *ChangePasswdRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCredentials not implemented")
}
func (UnimplementedAdminServer) NewUser(context.Context, *UserSignupRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewUser not implemented")
}
func (UnimplementedAdminServer) DeleteUser(context.Context, *UUID) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedAdminServer) UpdateUser(context.Context, *User) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedAdminServer) GetUserRoles(context.Context, *UUID) (*UserRoles, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserRoles not implemented")
}
func (UnimplementedAdminServer) UpdateUserRoles(context.Context, *UUID) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserRoles not implemented")
}
func (UnimplementedAdminServer) mustEmbedUnimplementedAdminServer() {}
func (UnimplementedAdminServer) testEmbeddedByValue()               {}

// UnsafeAdminServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AdminServer will
// result in compilation errors.
type UnsafeAdminServer interface {
	mustEmbedUnimplementedAdminServer()
}

func RegisterAdminServer(s grpc.ServiceRegistrar, srv AdminServer) {
	// If the following call pancis, it indicates UnimplementedAdminServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Admin_ServiceDesc, srv)
}

func _Admin_GetAllUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).GetAllUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Admin_GetAllUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).GetAllUsers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Admin_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).GetUser(ctx, req.(*UUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_GetUserTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).GetUserTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Admin_GetUserTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).GetUserTasks(ctx, req.(*UUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_UpdateCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePasswdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).UpdateCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Admin_UpdateCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).UpdateCredentials(ctx, req.(*ChangePasswdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_NewUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSignupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).NewUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Admin_NewUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).NewUser(ctx, req.(*UserSignupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Admin_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).DeleteUser(ctx, req.(*UUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Admin_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).UpdateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_GetUserRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).GetUserRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Admin_GetUserRoles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).GetUserRoles(ctx, req.(*UUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_UpdateUserRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).UpdateUserRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Admin_UpdateUserRoles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).UpdateUserRoles(ctx, req.(*UUID))
	}
	return interceptor(ctx, in, info, handler)
}

// Admin_ServiceDesc is the grpc.ServiceDesc for Admin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Admin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Admin",
	HandlerType: (*AdminServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllUsers",
			Handler:    _Admin_GetAllUsers_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _Admin_GetUser_Handler,
		},
		{
			MethodName: "GetUserTasks",
			Handler:    _Admin_GetUserTasks_Handler,
		},
		{
			MethodName: "UpdateCredentials",
			Handler:    _Admin_UpdateCredentials_Handler,
		},
		{
			MethodName: "NewUser",
			Handler:    _Admin_NewUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _Admin_DeleteUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _Admin_UpdateUser_Handler,
		},
		{
			MethodName: "GetUserRoles",
			Handler:    _Admin_GetUserRoles_Handler,
		},
		{
			MethodName: "UpdateUserRoles",
			Handler:    _Admin_UpdateUserRoles_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "schema.proto",
}

const (
	Auth_Signup_FullMethodName  = "/Auth/Signup"
	Auth_Login_FullMethodName   = "/Auth/Login"
	Auth_Refresh_FullMethodName = "/Auth/Refresh"
)

// AuthClient is the client API for Auth service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service for authentication-related operations.
type AuthClient interface {
	// Signs up a new user (no auth required)
	Signup(ctx context.Context, in *UserSignupRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	// Logs in an existing user using Basic auth ( ex: base64(username:password) )
	// providing the user with a pair of JWT (access + refresh)
	Login(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*LoginResponse, error)
	// Provides a new pair of JWT and revokes the refresh token provided to
	// make that request.
	Refresh(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*JWT, error)
}

type authClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthClient(cc grpc.ClientConnInterface) AuthClient {
	return &authClient{cc}
}

func (c *authClient) Signup(ctx context.Context, in *UserSignupRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, Auth_Signup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Login(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, Auth_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Refresh(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*JWT, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JWT)
	err := c.cc.Invoke(ctx, Auth_Refresh_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServer is the server API for Auth service.
// All implementations must embed UnimplementedAuthServer
// for forward compatibility.
//
// Service for authentication-related operations.
type AuthServer interface {
	// Signs up a new user (no auth required)
	Signup(context.Context, *UserSignupRequest) (*LoginResponse, error)
	// Logs in an existing user using Basic auth ( ex: base64(username:password) )
	// providing the user with a pair of JWT (access + refresh)
	Login(context.Context, *emptypb.Empty) (*LoginResponse, error)
	// Provides a new pair of JWT and revokes the refresh token provided to
	// make that request.
	Refresh(context.Context, *emptypb.Empty) (*JWT, error)
	mustEmbedUnimplementedAuthServer()
}

// UnimplementedAuthServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServer struct{}

func (UnimplementedAuthServer) Signup(context.Context, *UserSignupRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Signup not implemented")
}
func (UnimplementedAuthServer) Login(context.Context, *emptypb.Empty) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAuthServer) Refresh(context.Context, *emptypb.Empty) (*JWT, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}
func (UnimplementedAuthServer) mustEmbedUnimplementedAuthServer() {}
func (UnimplementedAuthServer) testEmbeddedByValue()              {}

// UnsafeAuthServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServer will
// result in compilation errors.
type UnsafeAuthServer interface {
	mustEmbedUnimplementedAuthServer()
}

func RegisterAuthServer(s grpc.ServiceRegistrar, srv AuthServer) {
	// If the following call pancis, it indicates UnimplementedAuthServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Auth_ServiceDesc, srv)
}

func _Auth_Signup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSignupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Signup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Auth_Signup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Signup(ctx, req.(*UserSignupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Auth_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Login(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_Refresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Refresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Auth_Refresh_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Refresh(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Auth_ServiceDesc is the grpc.ServiceDesc for Auth service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Auth_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Auth",
	HandlerType: (*AuthServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Signup",
			Handler:    _Auth_Signup_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _Auth_Login_Handler,
		},
		{
			MethodName: "Refresh",
			Handler:    _Auth_Refresh_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "schema.proto",
}
